{-|
Module      : Evaluator
Copyright   : (c) Alejandro De Cicco, 2021
License     : MIT
Maintainer  : alejandrodecicco99@gmail.com

The language's evaluator.
-}

module Evaluator where

import Control.Monad (unless, void, (>=>))

import AST
import BuiltInDefs
import BuiltInEval
import Errors
import EvaluatorEnv
import Utils (firstNotNull, getFunId, hasIterators)


-- -----------------
-- * Auxiliary

-- | Registers the functions in a program so that they can be called from anywhere.
registerFunctions :: Monad m => Program -> EvaluatorEnv m ()
registerFunctions = mapM_ registerFunction
    where
        registerFunction :: Monad m => Annotated Block -> EvaluatorEnv m ()
        registerFunction (FunDef _ title@(Title _ parts) _ sentences) =
            let fid = getFunId parts
                callable = FunCallable (void title) sentences
            in setFunctionCallable fid callable

-- | Returns a list of new variables to be declared and a list of references to be set when calling a function according to its signature.
variablesFromTitle :: ReadWrite m =>
    [Bare TitlePart] -- ^ The title of the function being called.
    -> [Bare Value] -- ^ The values being passed as arguments.
    -> EvaluatorEnv m ([([Name], Bare Value)], [([Name], Int)]) -- ^ The names in the title that should point to new values and the ones that should point to existing addresses.
variablesFromTitle _ [] = return ([], [])
variablesFromTitle (TitleWords _ _ : rest) vals = variablesFromTitle rest vals
variablesFromTitle (TitleParam _ names (RefT _) : rest) ((RefV _ addr):vals) = do
    (vars, refs) <- variablesFromTitle rest vals
    return (vars, (names, addr):refs)
variablesFromTitle (TitleParam _ names _ : rest) (val:vals) = do
    (vars, refs) <- variablesFromTitle rest vals
    return ((names, val):vars, refs)
variablesFromTitle [] (_:_) = error "Shouldn't happen: can't run out of title parts before running out of values in a function call"

-- | Finishes evaluating the references in the arguments of a function call if neccessary.
evaluateArguments :: ReadWrite m => [Bare TitlePart] -> [Bare Value] -> EvaluatorEnv m [Bare Value]
evaluateArguments _ [] = return []
evaluateArguments (TitleWords _ _ : rest) vals = evaluateArguments rest vals
evaluateArguments (TitleParam _ _ (RefT _) : rest) (val:vals) = (val:) <$> evaluateArguments rest vals
evaluateArguments (TitleParam {} : rest) (val:vals) = do
    val' <- evaluateReferences val
    (val':) <$> evaluateArguments rest vals
evaluateArguments [] (_:_) = error "Shouldn't happen: can't run out of title parts before running out of values in a function call"

-- | Takes a list value and returns a list of the values it contains.
getListValues :: ReadWrite m => Bare Value -> EvaluatorEnv m [Bare Value]
getListValues (ListV _ _ vs) = return vs
getListValues (RefV _ addr) = getValueAtAddress addr >>= getListValues
getListValues _ = error "Shouldn't happen: value is not a list"

-- | Returns the list of values generated by a value with iterators.
getIteratorValues :: ReadWrite m => Annotated Value -> EvaluatorEnv m [Bare Value]
getIteratorValues (IterV _ _ listVal)
    | hasIterators listVal = do
        generators <- (`withLocation` getIteratorValues) listVal
        vals <- mapM getListValues generators
        return $ concat vals
    | otherwise = do
        listVal' <- withLocation listVal evaluateUpToReference
        getListValues listVal'
getIteratorValues (OperatorCall _ fid args) = do
    ann <- getCurrentLocation
    vals <- mapM (`withLocation` getIteratorValues) args
    setCurrentLocation ann
    mapM (evaluateOperator fid) $ sequence vals
getIteratorValues val = do
    val' <- evaluateUpToReference val
    return [val']


-- -----------------
-- * Evaluators

-- | Recursively solves references in a partially evaluated value until it reaches a basic value.
-- If the argument is a list, a copy of it is returned.
evaluateReferences :: ReadWrite m => Bare Value -> EvaluatorEnv m (Bare Value)
evaluateReferences (VarV _ name) = do
    isDef <- variableIsDefined name
    unless isDef $ throwHere (UndefinedVariable name)
    getVariableValue name >>= evaluateReferences
evaluateReferences (RefV _ addr) = getValueAtAddress addr >>= evaluateReferences
evaluateReferences listVal@(ListV {}) = copyValue listVal
evaluateReferences val = return val

-- | Partially evaluates a value until a reference is reached.
-- If the argument is a list, it must be one created by extension so it is initialized.
evaluateUpToReference :: ReadWrite m => Annotated Value -> EvaluatorEnv m (Bare Value)
evaluateUpToReference (VarV _ name) = do
    isDef <- variableIsDefined name
    unless isDef $ throwHere (UndefinedVariable name)
    RefV () <$> getVariableAddress name
evaluateUpToReference (OperatorCall _ fid args) = do
    ann <- getCurrentLocation
    args' <- mapM (`withLocation` evaluateUpToReference) args
    setCurrentLocation ann
    evaluateOperator fid args'
evaluateUpToReference (ListV _ elemsType vals) = do
    vals' <- mapM (`withLocation` evaluateValue) vals
    addrs <- mapM addValue vals'
    return $ ListV () elemsType (map (RefV ()) addrs)
evaluateUpToReference val = return $ void val

-- | Evaluates a value until a basic value is reached.
evaluateValue :: ReadWrite m => Annotated Value -> EvaluatorEnv m (Bare Value)
evaluateValue (IterV {}) = error "Shouldn't happen: values with iterators must be solved before evaluating them"
evaluateValue (ValueM _ _) = error "Shouldn't happen: values must be solved before evaluating them"
evaluateValue val = evaluateUpToReference val >>= evaluateReferences

-- | Evaluates a sentence, with the possible side effect of triggering the garbage collector.
evaluateSentence :: ReadWrite m => Annotated Sentence -> EvaluatorEnv m (Maybe (Bare Value))
evaluateSentence s = tick >> evaluateSentence' s
    where
        evaluateSentence' :: ReadWrite m => Annotated Sentence -> EvaluatorEnv m (Maybe (Bare Value))
        evaluateSentence' (VarDef _ ~(name:names) _ val) = do
            val' <- case val of
                -- If the variable is being declared as a string, it can contain iterators.
                (ListV _ elemsType generators) -> do
                    vals <- concat <$> mapM (getIteratorValues >=> mapM evaluateReferences) generators
                    addrs <- mapM addValue vals
                    return $ ListV () elemsType (map (RefV ()) addrs)
                _ -> withLocation val evaluateValue
            setVariableValue name val'
            -- Declare the rest of the variables as copies of the original value so that they don't reference the same addresses.
            mapM_ (\name' -> copyValue val' >>= setVariableValue name') names
            return Nothing

        evaluateSentence' (If _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then evaluateSentences ss
                else return Nothing
        evaluateSentence' (IfElse _ boolVal ssTrue ssFalse) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then evaluateSentences ssTrue
                else evaluateSentences ssFalse

        evaluateSentence' (ForEach _ iterName _ listval ss) = do
            -- Set an auxiliary variable containing the values being iterated so that the garbage collector doesn't free them.
            -- ToDo: decouple notion of GC-roots from variable names.
            let auxName = "_" : iterName
            listVal' <- withLocation listval evaluateUpToReference
            elems <- case listVal' of
                (ListV _ _ elems) -> do
                    addr <- addValue listVal'
                    setVariableAddress auxName addr
                    return elems
                (RefV _ addr) -> do
                    ~(ListV _ _ elems) <- getValueAtAddress addr
                    setVariableAddress auxName addr
                    return elems
                _ -> error "Shouldn't happen: wrong type in loop"
            let loopIteration = (\(RefV _ addr) -> setVariableAddress iterName addr >> evaluateSentences ss)
            result <- firstNotNull loopIteration elems
            -- After the loop, the auxiliary variable is removed so that it can be freed by the garbage collector.
            removeVariable auxName
            removeVariable iterName
            return result

        evaluateSentence' sUntil@(Until _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then return Nothing
                else do
                    result <- evaluateSentences ss
                    case result of
                        (Just val) -> return $ Just val
                        Nothing -> evaluateSentence sUntil
        evaluateSentence' sWhile@(While _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then do
                    result <- evaluateSentences ss
                    case result of
                        (Just val) -> return $ Just val
                        Nothing -> evaluateSentence s
                else return Nothing

        evaluateSentence' (Return _ val) = do
            val' <- withLocation val evaluateValue
            return $ Just val'

        evaluateSentence' (ProcedureCall _ fid args) = do
            ann <- getCurrentLocation
            -- The arguments of procedure calls can be iterators. Each list contains the values to iterate for a function parameter.
            valsLists <- mapM (`withLocation` getIteratorValues) args
            setCurrentLocation ann
            mapM_ (evaluateProcedure fid) $ sequence valsLists
            return Nothing

        evaluateSentence' (Try _ ss) = evaluateSentences ss `catchCodeError` \_ -> return Nothing
        evaluateSentence' (TryCatch _ ssTry ssCatch) = evaluateSentences ssTry `catchCodeError` \_ -> evaluateSentences ssCatch
        evaluateSentence' (Throw _ msg) = throwHere $ CodeError msg

        evaluateSentence' (SentenceM _ _) = error "Shouldn't happen: sentences must be solved before evaluating them"

-- | Evaluates a list of sentences in a new block scope, discarding it afterwards.
evaluateSentences :: ReadWrite m => [Annotated Sentence] -> EvaluatorEnv m (Maybe (Bare Value))
evaluateSentences [] = return Nothing
evaluateSentences ss = inBlockScope $ firstNotNull evaluateSentenceWithLocation ss
    where
        evaluateSentenceWithLocation :: ReadWrite m => Annotated Sentence -> EvaluatorEnv m (Maybe (Bare Value))
        evaluateSentenceWithLocation s = do
            let ann = getLocation s
            result <- withLocation s evaluateSentence
            setCurrentLocation ann
            return result

-- | Returns the value resulting from evaluating an operator with the given arguments.
evaluateOperator :: ReadWrite m => FunId -> [Bare Value] -> EvaluatorEnv m (Bare Value)
evaluateOperator fid args = do
    result <- evaluateFunction fid args
    case result of
        Just val -> return val
        Nothing -> throwHere ExpectedResult

-- | Evaluates a procedure with the given arguments.
evaluateProcedure :: ReadWrite m => FunId -> [Bare Value] -> EvaluatorEnv m ()
evaluateProcedure fid args = void $ evaluateFunction fid args

-- | Evaluates any function with the given arguments, which must be partially evaluated.
evaluateFunction :: ReadWrite m =>  FunId -> [Bare Value] -> EvaluatorEnv m (Maybe (Bare Value))
evaluateFunction fid args = do
    (FunCallable (Title _ title) ss) <- getFunctionCallable fid
    -- Finish evaluating the arguments that are passed as copies.
    args' <- evaluateArguments title args
    if isBuiltInOperator fid
        then Just <$> evaluateBuiltInOperator fid args'
        else if isBuiltInProcedure fid
            then evaluateBuiltInProcedure fid args' >> return Nothing
            -- If the function is user defined, create a new scope.
            else do
                (vars, refs) <- variablesFromTitle title args'
                inNewScope (evaluateSentences ss) vars refs


-- -----------------
-- * Main

-- | Returns the result of evaluating a whole program, starting with the procedure called "Run".
evaluateProgram :: ReadWrite m => Program -> m (Either Error (((), Location), EvaluatorData))
evaluateProgram prog = runEvaluatorEnv (evaluateProgram' prog) initialLocation initialState
    where
        evaluateProgram' :: ReadWrite m => Program -> EvaluatorEnv m ()
        evaluateProgram' prog = do
            registerFunctions prog
            evaluateProcedure "run" []
