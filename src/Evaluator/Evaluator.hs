{-# LANGUAGE LiberalTypeSynonyms #-}
{-|
Module      : Evaluator
Copyright   : (c) Alejandro De Cicco, 2021
License     : MIT
Maintainer  : alejandrodecicco99@gmail.com

The language's evaluator.
-}

module Evaluator where

import Control.Monad (unless, void)
import Text.Read

import AST
import BuiltInDefs
import BuiltInEval
import Errors
import EvaluatorEnv
import PrettyPrinter (ppType, snippet)
import Utils (firstNotNull, getFunId, hasIterators)


-- -----------------
-- * Auxiliary

-- | The posible results of evaluating a sentence if it has any.
data EvalRes = ValRes (Bare Value) | BreakRes | ExitRes
    deriving (Eq, Show)

-- | Registers the functions in a program so that they can be called from anywhere.
registerFunctions :: Monad m => Program -> EvaluatorEnv m ()
registerFunctions = mapM_ registerFunction
    where
        registerFunction :: Monad m => Annotated Definition -> EvaluatorEnv m ()
        registerFunction (FunDef _ title _ sentences) =
            let fid = getFunId title
                callable = FunCallable (map void title) sentences
            in setFunctionCallable fid callable

-- | Returns a list of new variables to be declared and a list of references to be set when calling a function according to its signature.
variablesFromTitle :: ReadWrite m =>
    Bare Title -- ^ The title of the function being called.
    -> [Bare Value] -- ^ The values being passed as arguments.
    -> EvaluatorEnv m ([([Name], Bare Value)], [([Name], Int)]) -- ^ The names in the title that should point to new values and the ones that should point to existing addresses.
variablesFromTitle _ [] = return ([], [])
variablesFromTitle (TitleWords _ _ : rest) vals = variablesFromTitle rest vals
variablesFromTitle (TitleParam _ names (RefT _) : rest) ((RefV _ addr):vals) = do
    (vars, refs) <- variablesFromTitle rest vals
    return (vars, (names, addr):refs)
variablesFromTitle (TitleParam _ names _ : rest) (val:vals) = do
    (vars, refs) <- variablesFromTitle rest vals
    return ((names, val):vars, refs)
variablesFromTitle [] (_:_) = error "Shouldn't happen: can't run out of title parts before running out of values in a function call"

-- | Finishes evaluating the references in the arguments of a function call if neccessary.
evaluateArguments :: ReadWrite m => Bare Title -> [Bare Value] -> EvaluatorEnv m [Bare Value]
evaluateArguments _ [] = return []
evaluateArguments (TitleWords _ _ : rest) vals = evaluateArguments rest vals
evaluateArguments (TitleParam _ _ (RefT _) : rest) (val:vals) = (val:) <$> evaluateArguments rest vals
evaluateArguments (TitleParam {} : rest) (val:vals) = do
    val' <- evaluateReferences val
    (val':) <$> evaluateArguments rest vals
evaluateArguments [] (_:_) = error "Shouldn't happen: can't run out of title parts before running out of values in a function call"

-- | Takes a list value and returns a list of the values it contains.
getListElements :: ReadWrite m => Bare Value -> EvaluatorEnv m [Bare Value]
getListElements (ListV _ _ vs) = return vs
getListElements (RefV _ addr) = getValueAtAddress addr >>= getListElements
getListElements _ = error "Shouldn't happen: value is not a list"

-- | Returns the list of values generated by a value with iterators.
-- The garbage collector might be triggered midway, so it creates roots and returns their addresses.
getIteratorValues :: ReadWrite m => Annotated Value -> EvaluatorEnv m ([Bare Value], [Int])
getIteratorValues (IterV _ _ listVal)
    -- The value being iterated is a list of lists.
    | hasIterators listVal = do
        (listVals, roots) <- withLocation listVal getIteratorValues
        -- The iterator must go over each element in each list.
        genVals <- concat <$> mapM getListElements listVals
        return (genVals, roots)
    -- The value being iterated is a list.
    | otherwise = do
        listVal' <- withLocation listVal evaluateUpToReference
        root <- addValueRoot listVal'
        genVals <- getListElements listVal'
        return (genVals, [root])
getIteratorValues (OperatorCall _ fid args) = do
    ann <- getCurrentLocation
    -- The arguments of operator calls can be iterators.
    -- Each list contains the values to iterate for a function parameter.
    (valsLists, roots) <- getIteratorsValues args
    setCurrentLocation ann
    genVals <- mapM (evaluateOperator fid) $ sequence valsLists
    return (genVals, roots)
getIteratorValues val = do
    val' <- evaluateUpToReference val
    root <- addValueRoot val'
    return ([val'], [root])

-- | Returns a list of generated values for each value received.
-- The garbage collector might be triggered midway, so it creates roots at each step and returns their addresses.
getIteratorsValues :: ReadWrite m => [Annotated Value] -> EvaluatorEnv m ([[Bare Value]], [Int])
getIteratorsValues args = do
    iterRes <- mapM (`withLocation` getIteratorValues) args
    let valsLists = map fst iterRes
        roots = concatMap snd iterRes
    return (valsLists, roots)

-- | Loads a static list into memory.
initializeList :: ReadWrite m => Type -> [Bare Value] -> EvaluatorEnv m (Bare Value)
initializeList elemsType vals = do
    addrs <- mapM addValue vals
    return $ ListV () elemsType (map (RefV ()) addrs)

-- | Reads a value of the given type from input.
readValueFromInput :: ReadWrite m => Type -> EvaluatorEnv m (Bare Value)
readValueFromInput expType = do
    valStr <- liftReadWrite readValue
    case expType of
        IntT -> case readMaybe valStr of
            Just n -> return $ IntV () n
            Nothing -> throwNowhere $ CodeError ["Couldn't understand", snippet valStr, "as a", ppType expType]
        FloatT -> case readMaybe valStr of
            Just f -> return $ FloatV () f
            Nothing -> throwNowhere $ CodeError ["Couldn't understand", snippet valStr, "as a", ppType expType]
        BoolT -> case readMaybe valStr of
            Just b -> return $ BoolV () b
            Nothing -> throwNowhere $ CodeError ["Couldn't understand", snippet valStr, "as a", ppType expType]
        CharT -> case readMaybe valStr of
            Just c -> return $ CharV () c
            Nothing -> throwNowhere $ CodeError ["Couldn't understand", snippet valStr, "as a", ppType expType]
        ListT CharT -> initializeList CharT $ map (CharV ()) valStr
        _ -> error "Shouldn't happen: expected type is not a primitive"

-- -----------------
-- * Evaluators

-- | Recursively solves references in a partially evaluated value until it reaches a final value.
-- If the argument is a list, a copy of it is returned.
evaluateReferences :: ReadWrite m => Bare Value -> EvaluatorEnv m (Bare Value)
evaluateReferences (VarV _ name) = do
    isDef <- variableIsDefined name
    unless isDef $ throwHere (UndefinedVariable name)
    getVariableValue name >>= evaluateReferences
evaluateReferences (RefV _ addr) = getValueAtAddress addr >>= evaluateReferences
evaluateReferences listVal@(ListV {}) = copyValue listVal
evaluateReferences (InputV _ expType) = readValueFromInput expType
evaluateReferences val = return val

-- | Partially evaluates a value until a reference is reached.
-- If the argument is a list, it must be one created by extension so it is initialized.
evaluateUpToReference :: ReadWrite m => Annotated Value -> EvaluatorEnv m (Bare Value)
evaluateUpToReference (VarV _ name) = do
    isDef <- variableIsDefined name
    unless isDef $ throwHere (UndefinedVariable name)
    RefV () <$> getVariableAddress name
evaluateUpToReference (OperatorCall _ fid args) = do
    ann <- getCurrentLocation
    args' <- mapM (`withLocation` evaluateUpToReference) args
    setCurrentLocation ann
    evaluateOperator fid args'
evaluateUpToReference (ListV _ elemsType vals) = do
    vals' <- mapM (`withLocation` evaluateValue) vals
    initializeList elemsType vals'
evaluateUpToReference val = return $ void val

-- | Evaluates a value until a final value is reached.
evaluateValue :: ReadWrite m => Annotated Value -> EvaluatorEnv m (Bare Value)
evaluateValue (IterV {}) = error "Shouldn't happen: values with iterators must be solved before evaluating them"
evaluateValue (ValueM _ _) = error "Shouldn't happen: values must be solved before evaluating them"
evaluateValue val = evaluateUpToReference val >>= evaluateReferences

-- | Evaluates a sentence, with the possible side effect of triggering the garbage collector.
evaluateSentence :: ReadWrite m => Annotated Sentence -> EvaluatorEnv m (Maybe EvalRes)
evaluateSentence s = tick >> evaluateSentence' s
    where
        evaluateSentence' :: ReadWrite m => Annotated Sentence -> EvaluatorEnv m (Maybe EvalRes)
        evaluateSentence' (VarDef _ ~(name:names) _ val) = do
            val' <- case val of
                -- If the variable is being declared as a list by extension, it can contain iterators.
                (ListV _ elemsType generators) -> do
                    (valsLists, roots) <- getIteratorsValues generators
                    vals <- mapM evaluateReferences (concat valsLists)
                    addrs <- mapM addValue vals
                    removeRoots roots
                    return $ ListV () elemsType (map (RefV ()) addrs)
                _ -> withLocation val evaluateValue
            setVariableValue name val'
            -- Declare the rest of the variables as copies of the original value so that they don't reference the same addresses.
            mapM_ (\name' -> copyValue val' >>= setVariableValue name') names
            return Nothing

        evaluateSentence' (When _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then evaluateSentences ss
                else return Nothing
        evaluateSentence' (Unless _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then return Nothing
                else evaluateSentences ss
        evaluateSentence' (IfElse _ boolVal ssTrue ssFalse) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then evaluateSentences ssTrue
                else evaluateSentences ssFalse

        evaluateSentence' (ForEach _ iterNames _ listval ss) = do
            listVal' <- withLocation listval evaluateUpToReference
            -- Set the list being iterated as a root so that the garbage collector doesn't free it.
            root <- addValueRoot listVal'
            elems <- getListElements listVal'
            let loopIteration (~(RefV _ addr)) = mapM_ (`setVariableAddress` addr) iterNames >> evaluateSentences ss
            result <- firstNotNull loopIteration elems
            mapM_ removeVariable iterNames
            -- After the loop, remove the manually created root.
            removeRoot root
            case result of
                -- Consume the bubbled `break`.
                Just BreakRes -> return Nothing
                _ -> return result

        evaluateSentence' sUntil@(Until _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then return Nothing
                else do
                    result <- evaluateSentences ss
                    case result of
                        (Just BreakRes) -> return Nothing
                        (Just _) -> return result
                        Nothing -> evaluateSentence sUntil
        evaluateSentence' sWhile@(While _ boolVal ss) = do
            ~(BoolV _ cond) <- withLocation boolVal evaluateValue
            if cond
                then do
                    result <- evaluateSentences ss
                    case result of
                        (Just BreakRes) -> return Nothing
                        (Just _) -> return result
                        Nothing -> evaluateSentence s
                else return Nothing

        evaluateSentence' (Return _ val) = do
            val' <- withLocation val evaluateValue
            return $ Just (ValRes val')
        evaluateSentence' (Break _) = return $ Just BreakRes
        evaluateSentence' (Exit _) = return $ Just ExitRes

        evaluateSentence' (Read _ expType refVal) = do
            val <- readValueFromInput expType
            ~(RefV _ addr) <- withLocation refVal evaluateUpToReference
            setValueAtAddress addr val
            return Nothing
        evaluateSentence' (ProcedureCall _ fid args) = do
            ann <- getCurrentLocation
            -- The arguments of procedure calls can be iterators.
            -- Each list contains the values to iterate for a function parameter.
            (valsLists, roots) <- getIteratorsValues args
            setCurrentLocation ann
            mapM_ (evaluateProcedure fid) $ sequence valsLists
            removeRoots roots
            return Nothing

        evaluateSentence' (Attempt _ ss) = evaluateSentences ss `catchCodeError` \_ -> return Nothing
        evaluateSentence' (TryCatch _ ssTry ssCatch) = evaluateSentences ssTry `catchCodeError` \_ -> evaluateSentences ssCatch
        evaluateSentence' (Throw _ msg) = throwHere $ CodeError msg

        evaluateSentence' (SentenceM _ _) = error "Shouldn't happen: sentences must be solved before evaluating them"

-- | Evaluates a list of sentences in a new block scope, discarding it afterwards.
evaluateSentences :: ReadWrite m => [Annotated Sentence] -> EvaluatorEnv m (Maybe EvalRes)
evaluateSentences [] = return Nothing
evaluateSentences ss = inBlockScope $ firstNotNull evaluateSentenceWithLocation ss
    where
        evaluateSentenceWithLocation :: ReadWrite m => Annotated Sentence -> EvaluatorEnv m (Maybe EvalRes)
        evaluateSentenceWithLocation s = do
            let ann = getLocation s
            result <- withLocation s evaluateSentence
            setCurrentLocation ann
            return result

-- | Returns the value resulting from evaluating an operator with the given arguments, which must be partially evaluated.
evaluateOperator :: ReadWrite m => FunId -> [Bare Value] -> EvaluatorEnv m (Bare Value)
evaluateOperator fid args = do
    result <- evaluateFunction fid args
    case result of
        Just (ValRes val) -> return val
        Just _ -> error "Shouldn't happen: evaluating an operator must result in a value"
        Nothing -> throwHere ExpectedResult

-- | Evaluates a procedure with the given arguments, which must be partially evaluated.
evaluateProcedure :: ReadWrite m => FunId -> [Bare Value] -> EvaluatorEnv m ()
evaluateProcedure fid args = void $ evaluateFunction fid args

-- | Evaluates any function with the given arguments, which must be partially evaluated.
evaluateFunction :: ReadWrite m =>  FunId -> [Bare Value] -> EvaluatorEnv m (Maybe EvalRes)
evaluateFunction fid args = do
    (FunCallable title ss) <- getFunctionCallable fid
    -- Finish evaluating the arguments that are passed as copies.
    args' <- evaluateArguments title args
    if isBuiltInOperator fid
        then Just . ValRes <$> evaluateBuiltInOperator fid args'
        else if isBuiltInProcedure fid
            then evaluateBuiltInProcedure fid args' >> return Nothing
            -- If the function is user defined, create a new scope.
            else do
                (vars, refs) <- variablesFromTitle title args'
                inNewScope (evaluateSentences ss) vars refs


-- -----------------
-- * Main

-- | Returns the result of evaluating a whole program, starting with the procedure called "Run".
evaluateProgram :: ReadWrite m => Program -> m (Either Error (((), Location), EvaluatorData))
evaluateProgram prog = runEvaluatorEnv (evaluateProgram' prog) initialLocation initialState
    where
        evaluateProgram' :: ReadWrite m => Program -> EvaluatorEnv m ()
        evaluateProgram' prog = do
            registerFunctions prog
            evaluateProcedure "run" []
